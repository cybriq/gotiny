## <font color="#FF4500" >gotiny 只是个玩具，不建议使用。</font>


# gotiny   [![Build status][travis-img]][travis-url] [![License][license-img]][license-url] [![GoDoc][doc-img]][doc-url] [![Go Report Card](https://goreportcard.com/badge/github.com/niubaoshu/gotiny)](https://goreportcard.com/report/github.com/niubaoshu/gotiny)
gotiny是一个注重效率的go语言序列化库。gotiny通过预先生成编码机和减少使用reflect库等方式来提高效率，几乎和生成代码的序列化库有同样高的速度。
## hello word 
    package main
    import (
   	    "fmt"
   	    "github.com/niubaoshu/gotiny"
    )
    
    func main() {
   	    src1, src2 := "hello", []byte(" world!")
   	    ret1, ret2 := "", []byte{}
   	    gotiny.Unmarshal(gotiny.Marshal(&src1, &src2), &ret1, &ret2)
   	    fmt.Println(ret1 + string(ret2)) // print "hello world!"
    }

## 特性
- 效率非常的高，是golang自带序列化库gob的3倍以上,和一般的生成代码序列化框架处于同一水平，甚至高于它们。
- 除map类型外0内存申请。
- 支持编码所有的除func,chan类型外的所有golang内置类型和自定义类型。
- struct 类型会编码非导出字段,可通过golang tag 的方式设置不编码。
- 严格的类型转换。gotiny中只有类型完全相同的才会正确编码和解码。
- 编码带类型的nil值。
- 可以处理循环类型，不能编码循环值，会栈溢出。
- 所有可以编码的类型都会完全的解码，不论原值是什么和目标值是什么。
- 编码生成的字节串不包含类型信息，生成的字节数组非常小。
## 无法处理循环值 不支持循环引用  TODO 
	type a *a
	var b a
	b = &b

## install
```bash
$ go get -u github.com/niubaoshu/gotiny
```

## 编码协议
### 布尔类型
bool类型占用一位，真值编码为1，假值编码为0。当第一次遇到bool类型时会申请一个字节，将值编入最低位，第二次遇到时编入次低位，第九次遇到bool值时再申请一个字节编入最低位，以此类推。
### 整数类型
- uint8和int8 类型作为一个字节编入字符串的下一个字节。
- uint16,uint32,uint64,uint,uintptr 采用[Varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)编码方式。
- int16,int32,int64,int 采用ZigZag转换成一个无符号数后采用[Varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)编码方式。

### 浮点数类型
float32和float64采用[gob](https://golang.org/pkg/encoding/gob/)中对浮点类型的编码方式。
### 复数类型
- complex64类型会强转为一个uint64后采用uint64的编码方式。
- complex128类型分别将虚实部分作为float64类型编码。

### 字符串类型
字符串类型先将字符串长度强转为uint64类型编码，然后将字符串字节数组自身原样编码。
### 指针类型
指针类型判断是否为nil，如果是nil，编入一个bool类型的false值后结束，如果不为nil，编入一个bool类型true值，之后将指针解引用，按解引用后的类型编码。
### array和slice类型
先将长度强转为一个uint64后采用uint64的编码方式编入，然后将每一个元素安装自身的类型编码。
### map类型
同上，先编入长度，然后编入一个健，后面跟健对应的值，在编入一个健，接着是值，以此类推。
### struct类型
将结构体的所有成员按其类型编码，无论是否导出，非导出的字段也会编码。结构体会严格还原。
### 实现接口的类型
- 对于实现encoding包BinaryMarshaler/BinaryUnmarshaler 或 实现 gob包GobEncoder/GobDecoder 接口的类型会用实现的方法编码。
- 对于实现了gotiny.GoTinySerialize包的类型将采用实现的方法编码和解码

## benchmark
[benchmark](https://github.com/niubaoshu/go_serialization_benchmarks)


### License
MIT

[travis-img]: https://travis-ci.org/niubaoshu/gotiny.svg?branch=master
[travis-url]: https://travis-ci.org/niubaoshu/gotiny
[license-img]: http://img.shields.io/badge/license-MIT-green.svg?style=flat-square
[license-url]: http://opensource.org/licenses/MIT
[doc-img]: http://img.shields.io/badge/GoDoc-reference-blue.svg?style=flat-square
[doc-url]: https://godoc.org/github.com/niubaoshu/gotiny

Apologies for the google translate but here it is

gotiny is just a toy, not recommended.

gotiny ￼ ￼ ￼ ￼

gotiny is a serialization library for go language that focuses on efficiency. Gotiny improves efficiency by pre-generating the encoder and reducing the use of the reflect library, which is almost as fast as the serialization library that generates the code.

hello word

    package main
    
    import (
        "fmt"
        "github.com/niubaoshu/gotiny"
    )
    
    func main() {
        src1, src2 := "hello", []byte("world!")
        ret1, ret2 := "", []byte{}
        gotiny.Unmarshal(gotiny.Marshal(&src1, &src2), &ret1, &ret2)
        fmt.Println(ret1 + string(ret2)) // print "hello world!"
    }

characteristic

The efficiency is very high, more than 3 times that of golang's own serialization library gob, and it is at the same level as the general generated code serialization framework, or even higher than them.
0 memory allocations except for the map type.

Supports encoding all golang built-in types and custom types except func and chan types.
The struct type will encode non-exported fields, which can be set to not be encoded by golang tag.
Strict type conversion. Only the exact same type in gotiny will be encoded and decoded correctly.
Encodes a typed nil value.

It can handle loop types, but cannot encode loop values, which will cause stack overflow.
All types that can be encoded are fully decoded, regardless of the original value and the target value.
The byte string generated by the encoding does not contain type information, and the resulting byte array is very small.
Can't handle circular values ​​Circular references are not supported TODO

    type a *a
    var b a
    b = &b

install

$ go get -u github.com/niubaoshu/gotiny

encoding protocol

boolean type

The bool type occupies one bit, and the true value is encoded as 1, and the false value is encoded as 0. When the bool type is encountered for the first time, a byte will be applied, and the value will be programmed into the lowest digit. When the second encounter is encountered, the next lower digit will be applied. When the bool value is encountered for the ninth time, another byte will be applied and programmed into the lowest digit. , and so on.

Integer type

The uint8 and int8 types are programmed into the next byte of the string as a byte.
uint16, uint32, uint64, uint, uintptr use Varints encoding.

Int16, int32, int64, int use ZigZag to convert to an unsigned number and use Varints encoding.
floating point type

float32 and float64 use the encoding method for floating-point types in gob.

plural type

The complex64 type will be cast to a uint64 and then the uint64 encoding will be used.
The complex128 type encodes the virtual and real parts as float64 types, respectively.

String type

The string type first converts the string length to uint64 type encoding, and then encodes the string byte array itself as it is.

pointer type

The pointer type is judged whether it is nil. If it is nil, it will end with a bool type false value. If it is not nil, a bool type true value will be added, and then the pointer will be dereferenced and encoded according to the dereferenced type.

array and slice types

First convert the length to a uint64, and then use the uint64 encoding method to encode it, and then install each element with its own type encoding.

map type

Same as above, first program the length, then program a key, followed by the value corresponding to the health, then program a key, then the value, and so on.

struct type

Encodes all members of the struct by their type, whether exported or not, non-exported fields are also encoded. Structural experience is strictly reduced.

the type that implements the interface

For types that implement the encoding package BinaryMarshaler/BinaryUnmarshaler or the gob package GobEncoder/GobDecoder interface, the implemented method will be used for encoding.

For types that implement the gotiny.GoTinySerialize package, the implemented methods will be used to encode and decode

benchmark

benchmark

License

MIT